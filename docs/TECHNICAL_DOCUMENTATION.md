## Mini CRM — Technical Documentation

### 1) Executive summary
- **What it is**: A production-style CRM backend (FastAPI + SQLite) with contacts, leads, deals, activities, and a simple automation rules engine (webhooks, reminders, status transitions). Optional Streamlit front-end.
- **Why it matters**: Demonstrates ability to model sales pipelines, build integrations & automations, and ship demo-ready product workflows that resemble enterprise CRM processes.
- **Target audience**: Business development roles, integrations/solutions engineers, PMs, and technical interviewers.

### 2) Technology stack
- **FastAPI**: Web framework with async support and automatic OpenAPI docs.
- **Uvicorn**: ASGI server to run FastAPI.
- **SQLite**: Lightweight relational database, file-based, shareable.
- **SQLAlchemy 2.0**: ORM and database toolkit.
- **Pydantic 2.x**: Data validation and serialization for request/response schemas.
- **APScheduler**: In-process scheduler for periodic jobs (e.g., reminders).
- **httpx**: HTTP client for webhooks.
- **Streamlit**: Optional demo UI making API calls.
- **Docker**: Containerization for consistent local runs.

Pinned versions are listed in `requirements.txt`.

### 3) Architecture overview
- **Single service**: One FastAPI app process handles HTTP requests and runs the scheduler.
- **Database**: SQLite file `crm.db` with SQLAlchemy ORM models.
- **Automation engine**: Matches events (on_create, on_stage_change) and scheduled conditions (time_wait), executes actions (webhook, create_activity, update_status, create_deal, email mock).
- **Docs**: OpenAPI schemas auto-generated by FastAPI at `/docs` and `/openapi.json`.
- **Optional UI**: `streamlit_app.py` communicates with the API for a live demo.

Text diagram (conceptual):
- FastAPI ↔ SQLite (ORM via SQLAlchemy)
- FastAPI → automation engine (events) → actions (webhook/DB)
- APScheduler → periodic scans for time-based rules
- Streamlit → FastAPI endpoints (for demo)

### 4) Directory layout
- `app/main.py`: App factory, middleware, startup, routers registration, root + auth endpoints.
- `app/database.py`: Engine, session factory, `Base`, and `get_db` dependency.
- `app/models.py`: ORM models and enums.
- `app/schemas.py`: Pydantic request/response schemas.
- `app/auth.py`: Demo auth (static bearer token, token endpoint).
- `app/automation_engine.py`: Rule matching, action execution, and scheduler integration.
- `app/routers/`:
  - `contacts.py`: Contacts CRUD.
  - `leads.py`: Leads CRUD, activity create/list, status changes (fires rules).
  - `deals.py`: Deals create/list.
  - `automation.py`: Create/list rules, manual execute, logs listing.
  - `health.py`: Health endpoint.
- `requirements.txt`, `Dockerfile`, `docker-compose.yml`, `README.md`.
- `streamlit_app.py`: Optional demo UI.
- `docs/TECHNICAL_DOCUMENTATION.md`: This document.

### 5) Data model
- **Contacts** (`contacts`)
  - `id` (uuid string, PK)
  - `name`, `phone`, `email?`, `company?`
  - `created_at`, `updated_at`
- **Leads** (`leads`)
  - `id` (uuid string, PK), `contact_id` (FK → contacts)
  - `source` enum: `organic|ad|referral|manual`
  - `status` enum: `new|contacted|qualified|unqualified`
  - `assigned_to` (string)
  - `created_at`, `last_touch_at?`, `updated_at`
- **Deals** (`deals`)
  - `id` (uuid string, PK), `lead_id` (FK → leads)
  - `title`, `value` (float), `currency`
  - `stage` enum: `new|demo|proposal|won|lost`
  - `probability` (0–100), `created_at`, `updated_at`
- **ActivityLog** (`activity_logs`)
  - `id` (int PK), `lead_id` (FK), `activity_type` enum `call|message|note`
  - `text`, `created_by`, `created_at`
- **AutomationRule** (`automation_rules`)
  - `id` (int PK), `name` (unique)
  - `trigger_type` enum: `on_create|on_stage_change|time_wait`
  - `trigger_payload` (JSON), `action_type` enum
  - `action_payload` (JSON), `active` (bool), `created_at`
- **WebhookLog** (`webhook_logs`)
  - `id`, `automation_rule_id` (FK), `request_payload` (JSON), `response_status` (int?), `response_body` (text?), `created_at`

Key relationships:
- `Contact` 1→N `Lead`
- `Lead` 1→N `Deal`
- `Lead` 1→N `ActivityLog`
- `AutomationRule` 1→N `WebhookLog`

### 6) API surface
- Auth
  - `POST /auth/token` → returns `{ token: "demo-token", token_type: "bearer" }`
  - Protected routes require header: `Authorization: Bearer demo-token`
- Contacts
  - `POST /contacts` → create
  - `GET /contacts` → list
  - `GET /contacts/{id}` → retrieve
  - `PATCH /contacts/{id}` → partial update
  - `DELETE /contacts/{id}` → delete
- Leads
  - `POST /leads` → create (fires `on_create` rules)
  - `GET /leads?status=new` → list (optional filter)
  - `PATCH /leads/{id}` → update fields; when status changes, fires `on_stage_change` rules
  - `POST /leads/{id}/activity` → create a note/call/message and updates `last_touch_at`
  - `GET /leads/{id}/activity` → list activities
- Deals
  - `POST /deals` → create
  - `GET /deals` → list
- Automation
  - `POST /automation/rules` → create rule
  - `GET /automation/rules` → list rules
  - `POST /automation/execute/{rule_id}` → manual execute (for demos)
  - `GET /automation/rules/{id}/logs` → webhook logs for a rule
- Health
  - `GET /health` → `{ status: "ok" }`

All endpoints documented at `/docs` (Swagger UI) and `/openapi.json`.

### 7) Authentication model
- **Demo-only**: A static token `demo-token` protects non-auth endpoints.
- **Get token**: `POST /auth/token` (username/password ignored, returns static token).
- **Production note**: Replace with OAuth2/JWT + user store and RBAC.

### 8) Automation engine
- **Triggers**
  - `on_create`: fires when an entity is created (e.g., lead).
  - `on_stage_change`: fires when lead status changes (or deal stage changes if extended).
  - `time_wait`: evaluated by scheduler; e.g., leads with `status=new` and `last_touch_at` older than threshold → action.
- **Actions**
  - `webhook`: HTTP request to external endpoint; results logged to `WebhookLog`.
  - `create_activity`: adds an `ActivityLog` note (e.g., reminder).
  - `update_status`: changes a lead status.
  - `create_deal`: inserts a new `Deal` for the lead.
  - `email` (mock): logged as if sent.
- **Matching**
  - For each event, active rules are filtered by trigger type and optional payload filters.
  - Example: `on_stage_change` rule with payload `{ "status": "qualified" }` runs only when status becomes `qualified`.
- **Scheduling**
  - APScheduler runs an in-process background job every minute to evaluate `time_wait` rules.
  - You can configure trigger payload, e.g., `{ "entity": "lead", "status": "new", "hours_without_touch": 48 }`.

### 9) OpenAPI (What, Why, Where)
- **What**: OpenAPI is a standard schema for describing REST APIs (endpoints, inputs, outputs, auth).
- **Why**: Enables auto-generated docs, client SDKs, and integration tooling.
- **Where**: FastAPI auto-exposes at `/openapi.json` and interactive Swagger UI at `/docs`.

### 10) Streamlit (What, Why, Where)
- **What**: A Python framework for quickly building data/web apps with minimal code.
- **Why**: Ideal for demoing the CRM flows without building a full frontend.
- **Where**: `streamlit_app.py`. It calls the API (base URL configurable) and uses the demo token.

### 11) Running locally
- Create virtualenv and install:
```bash
python -m venv .venv
. .venv/Scripts/activate  # Windows Git Bash
pip install -r requirements.txt
pip install python-multipart  # if not already installed
```
- Start API:
```bash
.venv/Scripts/uvicorn app.main:app --host 0.0.0.0 --port 8000
```
- Open docs: `http://localhost:8000/docs`
- Test health:
```bash
curl http://localhost:8000/health
```
- Get token:
```bash
curl -X POST http://localhost:8000/auth/token -d "username=admin&password=pass"
```

### 12) Running Streamlit demo
- Ensure API is running on `http://localhost:8000`.
- Run Streamlit (any one of):
```bash
. .venv/Scripts/activate
streamlit run streamlit_app.py
# or
.venv/Scripts/python -m streamlit run streamlit_app.py
# or
./.venv/Scripts/streamlit run streamlit_app.py
```
- In the UI: set API base to `http://localhost:8000`, use `demo-token`.

### 13) Docker & Compose
- Build and run:
```bash
docker build -t mini-crm .
docker run -p 8000:8000 mini-crm
```
- Or with Compose:
```bash
docker compose up --build
```
- Environment:
  - `DATABASE_URL` (default `sqlite:///./crm.db`)
- Volumes (in compose): mounts project folder for quick iterations.

### 14) Example end-to-end demo flows
- Create contact → create lead → webhook rule → view logs
  1) Create a contact, capture `CONTACT_ID`.
  2) Create an `on_create` lead rule with `action_type=webhook` and your `WEBHOOK_URL`.
  3) Create a lead; a webhook POST is sent and logged.
  4) Check logs via `GET /automation/rules/{id}/logs`.
- Scheduled job reminder
  1) Create a `time_wait` rule with `hours_without_touch` (e.g., 1 for quick demo).
  2) Wait 1–2 minutes; scheduler runs per minute.
  3) Confirm a reminder activity on the lead.
- Status change → create deal + notify webhook
  1) Create `on_stage_change` rules: one `create_deal`, one `webhook` (optional).
  2) PATCH lead status to `qualified`.
  3) Verify new deal and webhook logs.

### 15) Design decisions & trade-offs
- **SQLite**: Simple and portable; fine for demo/small deployments; swap to Postgres/MySQL for multi-user concurrency.
- **In-process scheduler**: APScheduler is sufficient for single-instance demos; for scale/HA use Celery/RQ + Redis/Broker and run workers separately.
- **Static token auth**: Minimizes setup friction for demo; replace with OAuth2/JWT in production.
- **No migrations**: `Base.metadata.create_all()` is used; add Alembic for migrations in real projects.
- **Open CORS**: Eases demos; lock down origins in production.

### 16) Extensibility & future work
- Add users/teams, granular auth, roles/permissions.
- Add Alembic migrations and seed data.
- Add Celery + Redis for robust scheduling/queues.
- Webhook signature verification and retry/DLQ.
- Add tests (unit/integration) and CI.
- Observability: structured logging, metrics, tracing.
- Frontend: full React app or a more complete Streamlit UI.

### 17) Troubleshooting
- `Form data requires "python-multipart"`: install `python-multipart`.
- Port already in use: change `--port` or stop the existing process.
- Streamlit not found: run via venv `streamlit` or `python -m streamlit`.
- `Invalid contact_id`: create a contact first and use its actual id.
- `Lead not found` on activity: use the correct `LEAD_ID` from creation response.

### 18) Security notes (demo vs. production)
- This project is intentionally permissive (static token, open CORS) for demo speed.
- Production should add: proper identity, refresh tokens, RBAC, input validation hardening, rate limiting, secrets management, HTTPS, logging/monitoring.

### 19) Glossary
- **OpenAPI**: Standard format for describing REST APIs; used to auto-generate docs and clients.
- **Streamlit**: Python framework to build interactive data/web apps with minimal boilerplate.
- **FastAPI**: Modern Python web framework with type hints → automatic validation and docs.
- **SQLAlchemy**: ORM to map Python classes to database tables.
- **Pydantic**: Data validation and serialization via typed models.
- **APScheduler**: Job scheduler to run functions periodically.

### 20) FAQ
- **Q: Why build this?** A: To showcase end-to-end API design, data modeling, and automation that BD/sales orgs use (leads → deals → workflows).
- **Q: Who uses it?** A: Sales/BD teams, demo engineers, and interviewers evaluating technical fluency.
- **Q: How do I run automation?** A: Event rules fire upon create/update automatically; time-based rules are evaluated every minute by APScheduler. You can also call `POST /automation/execute/{rule_id}` to run a rule manually for demos.
- **Q: Where are docs?** A: `http://localhost:8000/docs` and `http://localhost:8000/openapi.json`.
- **Q: How do I change the DB?** A: Set `DATABASE_URL` (e.g., to Postgres DSN) and ensure the driver is installed.
- **Q: Can I add more actions?** A: Yes—extend the `ActionType` enum and implement a handler in `automation_engine.py`.

### 21) Beginner's Guide: Core Terms and Concepts

- **CRM (Customer Relationship Management)**: Software that helps businesses manage interactions with potential and existing customers. Tracks contacts, leads, deals, activities, and stages of a sales pipeline.

- **API (Application Programming Interface)**: A contract that lets software talk to other software. In web apps, APIs expose URLs (endpoints) you can call to create/read/update/delete data.

- **REST API**: A style of web API that uses standard HTTP methods (GET, POST, PATCH, DELETE) and resources (like /contacts, /leads). It is stateless: each request includes all info needed.

- **HTTP**: The protocol browsers and APIs use. A request has a URL, method, headers, and an optional body; a response has a status code, headers, and a body.

- **Status codes**: Numbers describing result of a request.
  - 200 OK (success), 201 Created (new resource), 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Server Error.

- **JSON**: A simple data format (text) for request/response bodies. Example:
  { "name": "Riya", "phone": "91234" }

- **Endpoint / Route**: A specific URL + method the API supports. Example: POST /contacts creates a contact.

- **Headers**: Meta-information sent with HTTP requests. Example: Authorization: Bearer demo-token.

- **Bearer token**: A security token included in the Authorization header to prove you are allowed to call protected endpoints.

- **CRUD**: Create, Read, Update, Delete – the common operations for data.

- **Schema (two meanings)**:
  - Database schema: the structure of tables/columns/relationships in a database.
  - API/data schema: a structured definition of input/output data. In this project, Pydantic models define schemas for requests and responses.

- **Model (ORM)** vs **Schema (DTO)**:
  - Model: A Python class mapped to a database table (SQLAlchemy). It represents how data is stored.
  - Schema/DTO: A Pydantic class that validates and shapes data in API boundaries (what you accept/return).

- **ORM (Object-Relational Mapping)**: A tool that lets you interact with the database using Python objects instead of writing raw SQL for everything.

- **SQLAlchemy**: The ORM we use. It maps classes (models) to tables, and lets you query and write data in Python.

- **SQLite**: A simple, file-based SQL database. Great for demos and small apps; for production scale, you’d use Postgres/MySQL.

- **UUID**: Universally Unique Identifier, used as string IDs for contacts, leads, and deals.

- **Primary Key (PK)**: The unique identifier for a row (e.g., `id`).

- **Foreign Key (FK)**: A reference to another table’s PK (e.g., `leads.contact_id` points to `contacts.id`).

- **Enum**: A fixed set of allowed values. Example: lead status is one of new, contacted, qualified, unqualified.

- **OpenAPI**: A standard (machine-readable) description of a REST API. FastAPI auto-generates this, enabling interactive docs at /docs and JSON at /openapi.json.

- **Swagger UI**: The interactive docs UI at /docs built from the OpenAPI spec. Lets you test endpoints in the browser.

- **FastAPI**: A modern Python web framework. Uses type hints to auto-validate data and generate OpenAPI docs.

- **ASGI / Uvicorn**: ASGI is an async server interface; Uvicorn is the ASGI server that runs FastAPI.

- **CORS (Cross-Origin Resource Sharing)**: Browser security policy controlling which web pages can call your API. We allow `*` (any origin) for easy demos.

- **Streamlit**: A Python framework to build quick interactive apps/dashboards. Our demo UI calls the API to create leads and update statuses.

- **Scheduler (APScheduler)**: Runs functions on a schedule (e.g., every minute). We use it to evaluate time-based rules like reminders.

- **Webhook**: An HTTP callback you send to another service when something happens (e.g., new lead). Our rules can POST to a URL and log the response.

- **Background job vs Request**:
  - Request: Happens when a client calls an endpoint; returns quickly.
  - Background job: Runs outside of the immediate request, often triggered by a schedule; not tied to a user waiting.

- **Environment variable**: A key/value available to the process (e.g., `DATABASE_URL=sqlite:///./crm.db`). Used for config without hard-coding values.

- **Docker**: Package your app with its dependencies into an image; run as a container. Ensures consistency across machines.
  - Image: The built artifact.
  - Container: A running instance of the image.
  - Port mapping: `-p 8000:8000` exposes the app on your host.
  - Volume: Mounting a host folder into the container (for live code updates or data).

- **Docker Compose**: Tool to define and run multi-container apps. Here it builds and starts the API.

- **Migration (Alembic)**: A script that changes the database schema over time. This demo uses `create_all()` instead; production should add Alembic.

- **Idempotent**: Safe to call multiple times without changing the result beyond the first time. GET is idempotent; POST usually is not.

- **PUT vs PATCH**:
  - PUT: Replace an entire resource (commonly expects the full object).
  - PATCH: Partially update specific fields (we use PATCH for updates).

- **Auth vs Authz**:
  - Authentication: Who are you?
  - Authorization: What are you allowed to do?

- **Rate limiting**: Restrict how many requests clients can make per time window to protect the service.

- **Retries / DLQ**:
  - Retry: Attempt a failed operation again.
  - Dead Letter Queue: A holding place for messages/actions that repeatedly fail, for later inspection.

- **Observability**:
  - Logs: Text records of events (errors, info).
  - Metrics: Numeric time-series (requests/sec, error rate).
  - Tracing: Follows a request across services for debugging latency.

- **SLA / SLI / SLO**:
  - SLA: Contract with customers about availability/performance.
  - SLI: A measured indicator (e.g., uptime %).
  - SLO: A target for an SLI (e.g., 99.9% uptime).

- **Scalability**:
  - Vertical scaling: Bigger machine.
  - Horizontal scaling: More instances behind a load balancer.
  - Stateless service: Any instance can handle any request (easier to scale).

- **API versioning**: Evolving APIs without breaking clients (e.g., /v1/..., fields deprecation).

- **Testing**:
  - Unit tests: Test small pieces in isolation.
  - Integration tests: Test components together (e.g., API + DB).

- **Continuous Integration (CI)**: Automatically run tests/lint/build on every change (e.g., GitHub Actions), catching issues early.

#### Simple examples
- GET a list of leads (Read):
  curl -H "Authorization: Bearer demo-token" http://localhost:8000/leads

- Create a contact (Create):
  curl -X POST http://localhost:8000/contacts/ \
    -H "Authorization: Bearer demo-token" -H "Content-Type: application/json" \
    -d '{ "name":"Riya","phone":"91234" }'

- Partial update a lead (PATCH):
  curl -X PATCH http://localhost:8000/leads/LEAD_ID \
    -H "Authorization: Bearer demo-token" -H "Content-Type: application/json" \
    -d '{ "status":"qualified" }'
